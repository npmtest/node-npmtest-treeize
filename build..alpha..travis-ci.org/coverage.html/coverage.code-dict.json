{"/home/travis/build/npmtest/node-npmtest-treeize/test.js":"/* istanbul instrument in package npmtest_treeize */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-treeize/lib.npmtest_treeize.js":"/* istanbul instrument in package npmtest_treeize */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_treeize = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_treeize = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-treeize/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-treeize && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_treeize */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_treeize\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_treeize.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_treeize.rollup.js'] =\n            local.assetsDict['/assets.npmtest_treeize.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_treeize.__dirname + '/lib.npmtest_treeize.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-treeize/node_modules/treeize/lib/treeize.js":"var util        = require('util');\nvar _           = require('lodash');\nvar inflection  = require('inflection');\nvar merge       = require('object-merge');\n\nfunction Treeize(options) {\n  this.baseOptions = {\n    input: {\n      delimiter:          ':',\n      detectCollections:  true,\n      uniformRows:        false,\n    },\n    output: {\n      prune:              true,\n      objectOverwrite:    true,\n      resultsAsObject:    false,\n    },\n    log:                  false,\n  };\n\n  this.data = {\n    signature: {\n      nodes: [],\n      type: null,\n    },\n    seed: [],\n    tree: [],\n  };\n\n  this.stats = {\n    time:     {\n      total:      0,\n      signatures: 0,\n    },\n    rows:         0,\n    sources:      0,\n  };\n\n  // set default options (below)\n  this.resetOptions();\n\n  if (options) {\n    this.options(options);\n  }\n\n  return this;\n}\n\nTreeize.prototype.log = function() {\n  if (this._options.log) {\n    console.log.apply(this, arguments);\n  }\n\n  return this;\n};\n\nTreeize.prototype.getData = function() {\n  return this.data.tree;\n};\n\nTreeize.prototype.getSeedData = function() {\n  return this.data.seed;\n};\n\nTreeize.prototype.getStats = function() {\n  return this.stats;\n};\n\n/*\n  Reads the signature from a given row to determine path mapping.  If passed without params, assumes\n  a forced reading which will last\n */\nTreeize.prototype.signature = function(row, options, auto) {\n  if (!row) {\n    return this.data.signature;\n  }\n\n  // start timer\n  var t1 = (new Date()).getTime();\n\n  // sets the signature as fixed (or not) when manually set\n  this.data.signature.isFixed = auto !== true;\n\n  var nodes         = this.data.signature.nodes = [];\n  var isArray       = _.isArray(row);\n  var opt           = merge(this._options, options || {});\n\n  this.data.signature.type = isArray ? 'array' : 'object';\n\n  _.each(row, function(value, key) {\n    // set up attribute\n    var attr        = {}\n\n    attr.key        = typeof key === 'number' ? key : key;//.replace(/^[\\*\\-\\+]|[\\*\\-\\+]$/g,'');\n    attr.fullPath   = isArray ? value : key;\n    attr.split      = attr.fullPath.split(opt.input.delimiter);\n    attr.path       = attr.split.slice(0,attr.split.length-1).join(opt.input.delimiter);\n    attr.parent     = attr.split.slice(0,attr.split.length-2).join(opt.input.delimiter);//.replace(/^[\\*\\-\\+]|[\\*\\-\\+]$/g,'');\n    attr.node       = attr.split[attr.split.length - 2];\n    attr.attr       = attr.split[attr.split.length - 1];\n\n    if (attr.attr.match(/\\*/gi)) {\n      attr.attr = attr.attr.replace(/[\\*]/gi,'');\n      attr.pk = true;\n    }\n\n    if (attr.pk) {\n      this.log('primary key detected in node \"' + attr.attr + '\"');\n    }\n\n    // set up node reference\n    var node = _.findWhere(nodes, { path: attr.path });\n    if (!node) {\n      node = { path: attr.path, attributes: [], blueprint: [] };\n      nodes.push(node);\n    }\n\n    node.isCollection = !attr.node || (opt.input.detectCollections && inflection.pluralize(attr.node) === attr.node);\n\n    var collectionFlag = attr.node && attr.node.match(/^[\\-\\+]|[\\-\\+]$/g);\n    if (collectionFlag) {\n      this.log('collection flag \"' + collectionFlag + '\" detected in node \"' + attr.node + '\"');\n      node.flags = true;\n      node.isCollection = attr.node.match(/^\\+|\\+$/g);\n      attr.node = attr.node.replace(/^[\\*\\-\\+]|[\\*\\-\\+]$/g,''); // clean node\n    }\n\n    node.name         = attr.node;\n    node.depth        = attr.split.length - 1;\n    node.parent       = attr.split.slice(0, attr.split.length - 2).join(opt.input.delimiter);\n    node.attributes.push({ name: attr.attr, key: attr.key });\n    if (attr.pk) {\n      this.log('adding node to blueprint');\n      node.flags = true;\n      node.blueprint.push({ name: attr.attr, key: attr.key });\n    }\n  }, this);\n\n  // backfill blueprint when not specifically defined\n  nodes.forEach(function(node) {\n    if (!node.blueprint.length) {\n      node.blueprint = node.attributes;\n    }\n  });\n\n  nodes.sort(function(a, b) { return a.depth < b.depth ? -1 : 1; });\n\n  // end timer and add time\n  var t2 = ((new Date()).getTime() - t1);\n  this.stats.time.signatures += t2;\n  this.stats.time.total += t2;\n\n  return this;\n};\n\nTreeize.prototype.getSignature = function() {\n  return this.signature();\n};\n\nTreeize.prototype.setSignature = function(row, options) {\n  return this.signature(row, options);\n};\n\nTreeize.prototype.setSignatureAuto = function(row, options) {\n  return this.signature(row, options, true);\n};\n\nTreeize.prototype.clearSignature = function() {\n  this.data.signature = { nodes: [], type: null };\n  this.data.signature.isFixed = false;\n\n  return this;\n};\n\n\nTreeize.prototype.grow = function(data, options) {\n  var opt = merge(this._options, options || {});\n\n  // chain past if no data to grow\n  if (!data || !_.isArray(data) || !data.length) {\n    return this;\n  }\n\n  this.log('OPTIONS>', opt);\n\n  // locate existing signature (when sharing signatures between data sources)\n  var signature = this.getSignature();\n\n  // set data uniformity (locally) to true to avoid signature fetching on data rows\n  if (_.isArray(data[0])) {\n    opt.input.uniformRows = true;\n  }\n\n  if (!signature.nodes.length) {\n    this.log('setting signature from first row of data (auto)');\n    // set signature from first row\n    signature = this.setSignatureAuto(data[0], options).getSignature();\n\n    // remove header row in flat array data (avoids processing headers as actual values)\n    if (_.isArray(data[0])) {\n      var originalData = data;\n      data = [];\n\n      // copy data without original signature row before processing\n      originalData.forEach(function(row, index) {\n        if (index > 0) {\n          data.push(row);\n        }\n      });\n    }\n  }\n\n  if (opt.output.resultsAsObject && _.isArray(this.data.tree)) {\n    this.data.tree = {};\n  }\n\n  this.log('SIGNATURE>', util.inspect(this.getSignature(), false, null));\n\n  this.stats.sources++;\n  var t1 = (new Date()).getTime();\n\n  data.forEach(function(row) {\n    this.data.seed.push(row);\n    var trails = {}; // LUT for trails (find parent of new node in trails path)\n    var trail = root = this.data.tree; // OPTIMIZATION: do we need to reset this trail for each row?\n    this.log('CURRENT TRAIL STATUS>', trail);\n    var t = null;\n\n    // set initial root object path for non-array datasets\n    if (opt.output.resultsAsObject) {\n      trails[''] = trail;\n    }\n\n    if (!this.data.signature.isFixed && !opt.input.uniformRows) {\n      this.log('setting signature from new row of data (auto)');\n      // get signature from each row\n      this.setSignatureAuto(row, opt);\n      this.log('SIGNATURE>', util.inspect(this.getSignature(), false, null));\n    }\n\n    this.stats.rows++;\n\n    if (_.where(this.signature().nodes, { flags: true }).length) {\n      // flags detected within signature, clean attributes of row\n      _.each(row, function(value, key) {\n        if (typeof key === 'string') {\n          var clean = key.replace(/^[\\*\\-\\+]|[\\*\\-\\+]$/g,'');\n          if (clean !== key) {\n            this.log('cleaning key \"' + key + '\" and embedding as \"' + clean + '\"');\n            row[key.replace(/^[\\*\\-\\+]|[\\*\\-\\+]$/g,'')] = value; // simply embed value at clean path (if not already)\n          }\n        }\n      }, this);\n    }\n\n    this.signature().nodes.forEach(function(node) {\n      this.log('PROCESSING NODE>', node);\n      var blueprint = {};\n      var blueprintExtended = {};\n\n      // create blueprint for locating existing nodes\n      node.blueprint.forEach(function(attribute) {\n        var key = (node.path ? (node.path + ':') : '') + attribute.name;\n        blueprint[attribute.name] = row[attribute.key];\n        this.log('creating attribute \"' + attribute.name + '\" within blueprint', row[attribute.key]);\n      }, this);\n\n      // create full node signature for insertion/updating\n      node.attributes.forEach(function(attribute) {\n        var key = (node.path ? (node.path + ':') : '') + attribute.name;\n        var value = row[attribute.key];\n\n        // insert extended blueprint attributes when not empty (or not pruning)\n        if (!opt.output.prune || (value !== null && value !== undefined)) {\n          this.log('creating attribute \"' + attribute.name + '\" within extended blueprint', row[attribute.key]);\n          blueprintExtended[attribute.name] = row[attribute.key];\n        }\n      }, this);\n\n      this.log('EXTENDED BLUEPRINT>', blueprintExtended);\n      this.log('BLUEPRINT>', blueprint);\n\n      // ONLY INSERT IF NOT PRUNED\n      if (!opt.output.prune || !_.isEmpty(blueprintExtended)) {\n        // IF 0 DEPTH AND RESULTSASOBJECT, EXTEND ROOT\n        if (opt.output.resultsAsObject && node.depth === 0) {\n          _.extend(trails[node.path] = trail = root, blueprintExtended);\n          this.log('extending blueprint onto root>', trail);\n\n        // IF ROOT TRAIL IS NOT YET MAPPED\n        } else if (node.isCollection && !(trail = trails[node.parent])) {\n          this.log('PARENT TRAIL NOT FOUND (ROOT?)');\n          // set up target node if doesn't exist\n          if (!(trail = _.findWhere(root, blueprint))) {\n            root.push(trail = blueprintExtended);\n          } else {\n            _.extend(trail, blueprintExtended);\n          }\n          trails[node.path] = trail;\n\n        // NORMAL NODE TRAVERSAL\n        } else {\n          // NOT ROOT CASE\n          if (node.isCollection) {\n            // handle collection nodes\n            this.log('inserting into collection node', trail);\n            if (!trail[node.name]) {\n              // node attribute doesnt exist, create array with fresh blueprint\n              trail[node.name] = [blueprintExtended];\n              trails[node.path] = blueprintExtended;\n            } else {\n              // node attribute exists, find or inject blueprint\n              var t;\n              if (!(t = _.findWhere(trail[node.name], blueprint))) {\n                trail[node.name].push(trail = blueprintExtended);\n              } else {\n                _.extend(t, blueprintExtended);\n              }\n              trails[node.path] = t || trail;\n            }\n          } else {\n            // handle non-collection nodes\n            if (trail == root && node.parent === '') {\n              root.push(trails[node.parent] = trail = {});\n              this.log('root insertion');\n            }\n            trail = trails[node.parent];\n\n            // ON DEEP NODES, THE PARENT WILL BE TOO LONG AND FAIL ON THE NEXT IF STATEMENT BELOW\n            // ASSUMPTION: in deep nodes, no signatures will be present, so entries will simply be pushed onto collections defined within\n\n            if (!trail) { // do something to fix a broken trail (usually from too deep?)\n              // backtrack from parent trail segments until trail found, then create creadcrumbs\n              var breadcrumbs = [];\n              var segments = node.parent.split(':');\n              var pathAttempt = node.parent;\n              var segmentsStripped = 0;\n\n              this.log('path MISSING for location \"' + pathAttempt + '\"');\n              while (!(trail = trails[pathAttempt])) {\n                segmentsStripped++;\n                pathAttempt = _.initial(segments, segmentsStripped).join(':');\n                this.log('..attempting path location for \"' + pathAttempt + '\"');\n\n                //infinite loop kickout\n                if (segmentsStripped > 15) break;\n              }\n              this.log('path FOUND for location for \"' + pathAttempt + '\" after removing ' + segmentsStripped + ' segments');\n\n              // create stored nodes if they don't exist.\n              _.each(_.rest(segments, segments.length - segmentsStripped), function(segment) {\n                var isCollection = ((inflection.pluralize(segment) === segment) || segment.match(/^\\+|\\+$/)) && (!segment.match(/^\\-|\\-$/));\n                // TODO: add modifier detection\n                this.log('creating or trailing path segment ' + (isCollection ? '[collection]' : '{object}') + ' \"' + segment + '\"');\n\n                segment = segment.replace(/^[\\*\\-\\+]|[\\*\\-\\+]$/g,'');\n                if (isCollection) {\n                  // retrieve or set collection segment and push new trail onto it\n                  (trail[segment] = trail[segment] || []).push(trail = {});\n                } else {\n                  trail = trail[segment] = trail[segment] || {};\n                }\n              }, this);\n            }\n\n            this.log('inserting into non-collection node');\n            //if (!trail[node.name]) { // TODO: CONSIDER: add typeof check to this for possible overwriting\n            if (!trail[node.name] || (opt.output.objectOverwrite && (typeof trail[node.name] !== typeof blueprintExtended))) {\n              // node attribute doesnt exist, create object\n              this.log('create object');\n              trail[node.name] = blueprintExtended;\n              trails[node.path] = blueprintExtended;\n            } else {\n              // node attribute exists, set path for next pass\n              // TODO: extend trail??\n              this.log('object at node \"' + node.name + '\" exists as \"' + trail[node.name] + '\", skipping insertion and adding trail');\n              if (typeof trail[node.name] === 'object') {\n                trail[node.name] = merge(trail[node.name], blueprintExtended);\n              }\n              this.log('trail[node.name] updated to \"' + trail[node.name]);\n              trails[node.path] = trail[node.path];\n            }\n          }\n        }\n        // END PRUNE PASS\n      }\n    }, this);\n  }, this);\n\n  var t2 = ((new Date()).getTime() - t1);\n  this.stats.time.total += t2;\n\n  // clear signature between growth sets - TODO: consider leaving this wipe pass off if processing multiple identical sources (add)\n  if (!signature.isFixed) {\n    this.signature([]);\n  }\n\n  return this;\n};\n\n/*\n  .[get|set]options (options)\n\n  Get and sets global options.\n */\n\nTreeize.prototype.options = function(options) {\n  if (!options) {\n    return merge({}, this._options);\n  }\n\n  this._options = merge(this._options, options);\n\n  return this;\n};\n\nTreeize.prototype.getOptions = function() {\n  return this._options;\n};\n\nTreeize.prototype.setOptions = function(options) {\n  return this.options(options);\n};\n\nTreeize.prototype.resetOptions = function() {\n  this._options = merge({}, this.baseOptions);\n\n  return this;\n};\n\nTreeize.prototype.toString = function treeToString() {\n  return util.inspect(this.data.tree, false, null);\n};\n\nmodule.exports = Treeize;\n","/home/travis/build/npmtest/node-npmtest-treeize/node_modules/treeize/sandbox/benchmark.js":"var util            = require('util');\nvar TreeizeStable   = require('./treeize-stable');\nvar TreeizeUnstable = require('../lib/treeize');\n\nvar welldata1       = require('../test/data/welldata1');\nvar welldata2       = require('../test/data/welldata2');\nvar arraywelldata   = require('../test/data/arraywelldata');\nvar classdata       = require('../test/data/classdata');\nvar Benchmark       = require('benchmark');\nvar _               = require('lodash');\n\nvar suite           = new Benchmark.Suite;\n\n// add tests\nsuite\n  .add('Treeize[Unstable]', function() {\n    var fields = new TreeizeUnstable();\n    fields\n      .grow(welldata1)\n      .grow(welldata2)\n      .grow(arraywelldata)\n    ;\n  })\n  .add('Treeize[Stable]', function() {\n    var fields = new TreeizeStable();\n    fields\n      .grow(welldata1)\n      .grow(welldata2)\n      .grow(arraywelldata)\n    ;\n  })\n  // add listeners\n  .on('cycle', function(event) {\n    console.log(String(event.target));\n  })\n  .on('complete', function() {\n    console.log('Fastest is ' + this.filter('fastest').pluck('name'));\n  })\n  // run async\n  .run({ 'async': true })\n;\n\n// console.log('KEYWORDS>', keywords + '');\n// console.log('STATS>', util.inspect(keywords.stats, false, null));\n","/home/travis/build/npmtest/node-npmtest-treeize/node_modules/treeize/sandbox/treeize-stable.js":"var util        = require('util');\nvar _           = require('lodash');\nvar inflection  = require('inflection');\nvar merge       = require('object-merge');\n\nfunction Treeize(options) {\n  this.baseOptions = {\n    input: {\n      delimiter:          ':',\n      detectCollections:  true,\n      uniformRows:        false,\n    },\n    output: {\n      prune:              true,\n      objectOverwrite:    true,\n      resultsAsObject:    false,\n    },\n    log:                  false,\n  };\n\n  this.data = {\n    signature: {\n      nodes: [],\n      type: null,\n    },\n    seed: [],\n    tree: [],\n  };\n\n  this.stats = {\n    time:     {\n      total:      0,\n      signatures: 0,\n    },\n    rows:         0,\n    sources:      0,\n  };\n\n  // set default options (below)\n  this.resetOptions();\n\n  if (options) {\n    this.options(options);\n  }\n\n  return this;\n}\n\nTreeize.prototype.log = function() {\n  if (this._options.log) {\n    console.log.apply(this, arguments);\n  }\n\n  return this;\n};\n\nTreeize.prototype.getData = function() {\n  return this.data.tree;\n};\n\nTreeize.prototype.getStats = function() {\n  return this.stats;\n};\n\n/*\n  Reads the signature from a given row to determine path mapping.  If passed without params, assumes\n  a forced reading which will last\n */\nTreeize.prototype.signature = function(row, options, auto) {\n  if (!row) {\n    return this.data.signature;\n  }\n\n  // start timer\n  var t1 = (new Date()).getTime();\n\n  // sets the signature as fixed (or not) when manually set\n  this.data.signature.isFixed = auto !== true;\n\n  var nodes         = this.data.signature.nodes = [];\n  var isArray       = _.isArray(row);\n  var opt           = merge(this._options, options || {});\n\n  this.data.signature.type = isArray ? 'array' : 'object';\n\n  _.each(row, function(value, key) {\n    // set up attribute\n    var attr        = {}\n\n    attr.key        = typeof key === 'number' ? key : key.replace(/^[\\*\\-\\+]|[\\*\\-\\+]$/g,'');\n    attr.fullPath   = isArray ? value : key;\n    attr.split      = attr.fullPath.split(opt.input.delimiter);\n    attr.path       = attr.split.slice(0,attr.split.length-1).join(opt.input.delimiter);\n    attr.parent     = attr.split.slice(0,attr.split.length-2).join(opt.input.delimiter).replace(/^[\\*\\-\\+]|[\\*\\-\\+]$/g,'');\n    attr.node       = attr.split[attr.split.length - 2];\n    attr.attr       = attr.split[attr.split.length - 1];\n\n    if (attr.attr.match(/\\*/gi)) {\n      attr.attr = attr.attr.replace(/[\\*]/gi,'');\n      attr.pk = true;\n    }\n\n    if (attr.pk) {\n      this.log('primary key detected in node \"' + attr.attr + '\"');\n    }\n\n    // set up node reference\n    var node = _.findWhere(nodes, { path: attr.path });\n    if (!node) {\n      node = { path: attr.path, attributes: [], blueprint: [] };\n      nodes.push(node);\n    }\n\n    node.isCollection = !attr.node || (opt.input.detectCollections && inflection.pluralize(attr.node) === attr.node);\n\n    var collectionFlag = attr.node && attr.node.match(/^[\\-\\+]|[\\-\\+]$/g);\n    if (collectionFlag) {\n      this.log('collection flag \"' + collectionFlag + '\" detected in node \"' + attr.node + '\"');\n      node.flags = true;\n      node.isCollection = attr.node.match(/^\\+|\\+$/g);\n      attr.node = attr.node.replace(/^[\\*\\-\\+]|[\\*\\-\\+]$/g,''); // clean node\n    }\n\n    node.name         = attr.node;\n    node.depth        = attr.split.length - 1;\n    node.parent       = _.initial(attr.split, 2).join(opt.input.delimiter);\n    node.attributes.push({ name: attr.attr, key: attr.key });\n    if (attr.pk) {\n      this.log('adding node to blueprint');\n      node.flags = true;\n      node.blueprint.push({ name: attr.attr, key: attr.key });\n    }\n  }, this);\n\n  // backfill blueprint when not specifically defined\n  _.each(nodes, function(node) {\n    if (!node.blueprint.length) {\n      node.blueprint = node.attributes;\n    }\n  });\n\n  nodes.sort(function(a, b) { return a.depth < b.depth ? -1 : 1; });\n\n  // end timer and add time\n  var t2 = ((new Date()).getTime() - t1);\n  this.stats.time.signatures += t2;\n  this.stats.time.total += t2;\n\n  return this;\n};\n\nTreeize.prototype.getSignature = function() {\n  return this.signature();\n};\n\nTreeize.prototype.setSignature = function(row, options) {\n  return this.signature(row, options);\n};\n\nTreeize.prototype.setSignatureAuto = function(row, options) {\n  return this.signature(row, options, true);\n};\n\nTreeize.prototype.clearSignature = function() {\n  this.data.signature = { nodes: [], type: null };\n  this.data.signature.isFixed = false;\n\n  return this;\n};\n\n\nTreeize.prototype.grow = function(data, options) {\n  var opt = merge(this._options, options || {});\n\n  // chain past if no data to grow\n  if (!data || !_.isArray(data) || !data.length) {\n    return this;\n  }\n\n  this.log('OPTIONS>', opt);\n\n  // locate existing signature (when sharing signatures between data sources)\n  var signature = this.getSignature();\n\n  // set data uniformity (locally) to true to avoid signature fetching on data rows\n  if (_.isArray(data[0])) {\n    opt.input.uniformRows = true;\n  }\n\n  if (!signature.nodes.length) {\n    this.log('setting signature from first row of data (auto)');\n    // set signature from first row\n    signature = this.setSignatureAuto(data[0], options).getSignature();\n\n    // remove header row in flat array data (avoids processing headers as actual values)\n    if (_.isArray(data[0])) {\n      var originalData = data;\n      data = [];\n\n      // copy data without original signature row before processing\n      _.each(originalData, function(row, index) {\n        if (index > 0) {\n          data.push(row);\n        }\n      });\n    }\n  }\n\n  if (opt.output.resultsAsObject && _.isArray(this.data.tree)) {\n    this.data.tree = {};\n  }\n\n  this.log('SIGNATURE>', util.inspect(this.getSignature(), false, null));\n\n  this.stats.sources++;\n  var t1 = (new Date()).getTime();\n\n  _.each(data, function(row) {\n    var trails = {}; // LUT for trails (find parent of new node in trails path)\n    var trail = root = this.data.tree; // OPTIMIZATION: do we need to reset this trail for each row?\n    this.log('CURRENT TRAIL STATUS>', trail);\n    var t = null;\n\n    // set initial root object path for non-array datasets\n    if (opt.output.resultsAsObject) {\n      trails[''] = trail;\n    }\n\n    if (!this.data.signature.isFixed && !opt.input.uniformRows) {\n      this.log('setting signature from new row of data (auto)');\n      // get signature from each row\n      this.setSignatureAuto(row, opt);\n      this.log('SIGNATURE>', util.inspect(this.getSignature(), false, null));\n    }\n\n    this.stats.rows++;\n\n    if (_.where(this.signature().nodes, { flags: true }).length) {\n      // flags detected within signature, clean attributes of row\n      _.each(row, function(value, key) {\n        if (typeof key === 'string') {\n          var clean = key.replace(/^[\\*\\-\\+]|[\\*\\-\\+]$/g,'');\n          if (clean !== key) {\n            this.log('cleaning key \"' + key + '\" and embedding as \"' + clean + '\"');\n            row[key.replace(/^[\\*\\-\\+]|[\\*\\-\\+]$/g,'')] = value; // simply embed value at clean path (if not already)\n          }\n        }\n      }, this);\n    }\n\n    _.each(this.signature().nodes, function(node) {\n      this.log('PROCESSING NODE>', node);\n      var blueprint = {};\n      var blueprintExtended = {};\n\n      // create blueprint for locating existing nodes\n      _.each(node.blueprint, function(attribute) {\n        var key = (node.path ? (node.path + ':') : '') + attribute.name;\n        blueprint[attribute.name] = row[attribute.key];\n        this.log('creating attribute \"' + attribute.name + '\" within blueprint', row[attribute.key]);\n      }, this);\n\n      // create full node signature for insertion/updating\n      _.each(node.attributes, function(attribute) {\n        var key = (node.path ? (node.path + ':') : '') + attribute.name;\n        var value = row[attribute.key];\n\n        // insert extended blueprint attributes when not empty (or not pruning)\n        if (!opt.output.prune || (value !== null && value !== undefined)) {\n          this.log('creating attribute \"' + attribute.name + '\" within extended blueprint', row[attribute.key]);\n          blueprintExtended[attribute.name] = row[attribute.key];\n        }\n      }, this);\n\n      this.log('EXTENDED BLUEPRINT>', blueprintExtended);\n      this.log('BLUEPRINT>', blueprint);\n\n      // ONLY INSERT IF NOT PRUNED\n      if (!opt.output.prune || !_.isEmpty(blueprintExtended)) {\n        // IF 0 DEPTH AND RESULTSASOBJECT, EXTEND ROOT\n        if (opt.output.resultsAsObject && node.depth === 0) {\n          _.extend(trails[node.path] = trail = root, blueprintExtended);\n          this.log('extending blueprint onto root>', trail);\n\n        // IF ROOT TRAIL IS NOT YET MAPPED\n        } else if (node.isCollection && !(trail = trails[node.parent])) {\n          this.log('PARENT TRAIL NOT FOUND (ROOT?)');\n          // set up target node if doesn't exist\n          if (!(trail = _.findWhere(root, blueprint))) {\n            root.push(trail = blueprintExtended);\n          } else {\n            _.extend(trail, blueprintExtended);\n          }\n          trails[node.path] = trail;\n\n        // NORMAL NODE TRAVERSAL\n        } else {\n          // NOT ROOT CASE\n          if (node.isCollection) {\n            // handle collection nodes\n            this.log('inserting into collection node', trail);\n            if (!trail[node.name]) {\n              // node attribute doesnt exist, create array with fresh blueprint\n              trail[node.name] = [blueprintExtended];\n              trails[node.path] = blueprintExtended;\n            } else {\n              // node attribute exists, find or inject blueprint\n              var t;\n              if (!(t = _.findWhere(trail[node.name], blueprint))) {\n                trail[node.name].push(trail = blueprintExtended);\n              } else {\n                _.extend(t, blueprintExtended);\n              }\n              trails[node.path] = t || trail;\n            }\n          } else {\n            // handle non-collection nodes\n            if (trail == root && node.parent === '') {\n              root.push(trails[node.parent] = trail = {});\n              this.log('root insertion');\n            }\n            trail = trails[node.parent];\n\n            // ON DEEP NODES, THE PARENT WILL BE TOO LONG AND FAIL ON THE NEXT IF STATEMENT BELOW\n            // ASSUMPTION: in deep nodes, no signatures will be present, so entries will simply be pushed onto collections defined within\n\n            if (!trail) { // do something to fix a broken trail (usually from too deep?)\n              // backtrack from parent trail segments until trail found, then create creadcrumbs\n              var breadcrumbs = [];\n              var segments = node.parent.split(':');\n              var pathAttempt = node.parent;\n              var segmentsStripped = 0;\n\n              this.log('path MISSING for location \"' + pathAttempt + '\"');\n              while (!(trail = trails[pathAttempt])) {\n                segmentsStripped++;\n                pathAttempt = _.initial(segments, segmentsStripped).join(':');\n                this.log('..attempting path location for \"' + pathAttempt + '\"');\n\n                //infinite loop kickout\n                if (segmentsStripped > 5) break;\n              }\n              this.log('path FOUND for location for \"' + pathAttempt + '\" after removing ' + segmentsStripped + ' segments');\n\n              // create stored nodes if they don't exist.\n              _.each(_.rest(segments, segments.length - segmentsStripped), function(segment) {\n                var isCollection = ((inflection.pluralize(segment) === segment) || segment.match(/^\\+|\\+$/)) && (!segment.match(/^\\-|\\-$/));\n                // TODO: add modifier detection\n                this.log('creating or trailing path segment ' + (isCollection ? '[collection]' : '{object}') + ' \"' + segment + '\"');\n\n                segment = segment.replace(/^[\\*\\-\\+]|[\\*\\-\\+]$/g,'');\n                if (isCollection) {\n                  // retrieve or set collection segment and push new trail onto it\n                  (trail[segment] = trail[segment] || []).push(trail = {});\n                } else {\n                  trail = trail[segment] = trail[segment] || {};\n                }\n              }, this);\n            }\n\n            this.log('inserting into non-collection node');\n            //if (!trail[node.name]) { // TODO: CONSIDER: add typeof check to this for possible overwriting\n            if (!trail[node.name] || (opt.output.objectOverwrite && (typeof trail[node.name] !== typeof blueprintExtended))) {\n              // node attribute doesnt exist, create object\n              this.log('create object');\n              trail[node.name] = blueprintExtended;\n              trails[node.path] = blueprintExtended;\n            } else {\n              // node attribute exists, set path for next pass\n              // TODO: extend trail??\n              this.log('object at node \"' + node.name + '\" exists as \"' + trail[node.name] + '\", skipping insertion and adding trail');\n              if (_.isObject(trail[node.name])) {\n                trail[node.name] = merge(trail[node.name], blueprintExtended);\n              }\n              this.log('trail[node.name] updated to \"' + trail[node.name]);\n              trails[node.path] = trail[node.path];\n            }\n          }\n        }\n        // END PRUNE PASS\n      }\n    }, this);\n  }, this);\n\n  var t2 = ((new Date()).getTime() - t1);\n  this.stats.time.total += t2;\n\n  // clear signature between growth sets - TODO: consider leaving this wipe pass off if processing multiple identical sources (add)\n  if (!signature.isFixed) {\n    this.signature([]);\n  }\n\n  return this;\n};\n\n/*\n  .[get|set]options (options)\n\n  Get and sets global options.\n */\n\nTreeize.prototype.options = function(options) {\n  if (!options) {\n    return merge({}, this._options);\n  }\n\n  this._options = merge(this._options, options);\n\n  return this;\n};\n\nTreeize.prototype.getOptions = function() {\n  return this._options;\n};\n\nTreeize.prototype.setOptions = function(options) {\n  return this.options(options);\n};\n\nTreeize.prototype.resetOptions = function() {\n  this._options = merge({}, this.baseOptions);\n\n  return this;\n};\n\nTreeize.prototype.toString = function treeToString() {\n  return util.inspect(this.data.tree, false, null);\n};\n\nmodule.exports = Treeize;\n","/home/travis/build/npmtest/node-npmtest-treeize/node_modules/treeize/sandbox/demo.js":"var util            = require('util');\nvar Treeize         = require('../lib/treeize');\n\nvar welldata1       = require('../test/data/welldata1');\nvar welldata2       = require('../test/data/welldata2');\nvar arraywelldata   = require('../test/data/arraywelldata');\nvar classdata   = require('../test/data/classdata');\n// var CSV             = require('a-csv');\nvar _               = require('lodash');\n\nvar fields = new Treeize();\n// fields\n//       .setOptions({ input: { uniformRows: false } })\n//       .grow(welldata1)\n//       .grow(welldata2)\n//       .grow(arraywelldata)\n//     ;\n\n    fields\n      .setOptions({ input: { uniformRows: false } })\n      .grow(welldata1)\n      .grow(welldata2)\n      .grow(arraywelldata)\n    ;\n\n// test node dependency\n\nvar testData = [\n  {\n    'name': 'John Doe',\n    'age': 34,\n    'pets:name': 'Rex',\n    'pets:type': 'dog',\n    'pets:toys:type': 'bone'\n  },\n  {\n    'name': 'John Doe',\n    'age': 34,\n    'pets:name': 'Rex',\n    'pets:type': 'dog',\n    'pets:toys:type': 'ball'\n  },\n  {\n    'name': 'Mary Jane',\n    'age': 19,\n    'pets:name': 'Mittens',\n    'pets:type': 'cat',\n    'pets:toys:type': 'yarn'\n  },\n  {\n    'name': 'Mary Jane',\n    'age': 19,\n    'pets:name': 'Fluffy',\n    'pets:type': 'cat',\n  }\n];\n\ntestData = [\n  ['name', 'age', 'pets:name', 'pets:type', 'pets:toys:type'],\n  ['John Doe', 34, 'Rex', 'dog', 'bone'],\n  ['John Doe', 34, 'Rex', 'dog', 'ball'],\n  ['Mary Jane', 19, 'Mittens', 'cat', 'yarn'],\n  ['Mary Jane', 19, 'Fluffy', 'cat', null]\n];\n\n// var test4 = new Treeize();\n// test4\n//   .setOptions({ log: true, input: { uniformRows: false } })\n//   .grow(testNodeDependency)\n// ;\n\n// var keywords = new Treeize();\n// keywords.grow(keywordsTest);\n\n// console.log('BASE>', test4 + '');\n// console.log('STATS>', util.inspect(test4.stats, false, null), \"\\n\\n\");\n\n// parseXlsx('injection.xlsx', function(err, data) {\n//     console.log('err', err);\n//     if(err) throw err;\n//     console.log('data read successfully');\n//     // data is an array of arrays\n// });\n\n\nvar data = [];\n\nvar options = {\n  delimiter: \"|\",\n  charset: \"win1250\"\n};\n\n// CSV.parse(__dirname + '/test/data/mooc2.csv', options, function (err, row, next) {\n//   if (err) {\n//     return console.log(err);\n//   }\n\n//   if (row) {\n//     data.push(row);\n//     return next();\n//   }\n\n//   if (!row) {\n//     var universities = new Treeize();\n//     universities\n//       // .setOptions({ log: true })\n//       .grow(data)\n//     ;\n\n//     console.log('BASE>', universities + '');\n//     console.log('STATS>', util.inspect(universities.stats, false, null), \"\\n\\n\");\n//   }\n// });\n\n\nvar tree = new Treeize();\n\ntree.grow(testData);\n\n// var tree = new Treeize();\n\n// tree.setOptions({ log: true }).grow([\n//   { 'foo': 'bar', 'logs:id': 'abc', 'logs:a:b': 1 },\n//   { 'foo': 'bar', 'logs:id': 'abc', 'logs:a:b': 2 },\n//   { 'foo': 'baz', 'logs:id': 'abc', 'logs:a:b': 3 },\n// ]);\n\n// tree.setOptions({ log: true }).grow([\n//   { 'foo': 'bar', 'logs-:a:b:c': 1 },\n//   { 'foo': 'bar', 'logs-:a:b:c': 2 },\n//   { 'foo': 'baz', 'logs-:a:b:c': 3 },\n// ]);\n\n// tree.setOptions({ log: true }).grow([\n//   { 'foo': 'bar', 'logs:a': 1 },\n//   { 'foo': 'bar', 'logs:a': 2 },\n//   { 'foo': 'baz', 'logs:a': 3 },\n// ]);\n\nconsole.log('BASE>', tree + '');\nconsole.log('STATS>', util.inspect(tree.stats, false, null), \"\\n\\n\");\n\n// console.log('KEYWORDS>', keywords + '');\n// console.log('STATS>', util.inspect(keywords.stats, false, null));\n"}